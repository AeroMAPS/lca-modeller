from typing import Dict, List, Union
import os
import dill
import lca_algebraic as agb
from lca_algebraic.log import warn
from lca_algebraic import ValueOrExpression
import pandas as pd
from sympy.parsing.sympy_parser import parse_expr
from sympy import Float, S
import numpy as np
import concurrent.futures

USER_DB = 'Foreground DB'
DEFAULT_PROJECT = 'lcav_default_project'


class LCAProblemReduced:
    """
    DEPRECATED (TO BE UPDATED).
    Reduced LCA Problem.
    This reduced problem does not require EcoInvent and to setup a brightway/lca_algebraic project.
    It is generated by a full LCA problem (see LCAProblem class).
    The LCIA relies on previously compiled expressions of the impacts.
    """

    def __init__(self, load_from_file: str = None):
        self.model = None  # model
        self.methods = None  # LCIA methods
        self.lambdas = None  # Compiled expressions of impacts
        self.param_registry = None  # Parameters
        self.df_processes = None

        if load_from_file is not None:
            self._load(load_from_file)

    def _load(self, file_path: str):
        """
        Loads a pre-existing LCA problem.
        """
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        with open(file_path, 'rb') as file:
            data = dill.load(file)
            self.__dict__.update(data)

        print(f"Loaded LCA problem from {file_path}.")

    def save(self, file_path: str):
        """
        Saves the LCA problem for future use.
        """
        if not self.lambdas:
            warn("No symbolic expression registered in LCA problem.")
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        dill.dump(self.__dict__, file=open(file_path, 'wb'))  # Export LCAProblemReduced attributes
        print(f"LCA problem saved in {file_path}.")

    def compute_lcia(self, alpha=1, **params):
        """
        Modified version of postMultiLCAAlgebric from lca_algebraic library.

        Parameters
        ----------
        **params : dictionary of parameters and their values for calculating the LCIA
        """

        if self.lambdas is None:
            warn("No symbolic expression registered in LCA problem.")
            return None

        param_length = agb.lca._compute_param_length(params)

        # Init output
        res = np.zeros((len(self.methods), param_length), float)

        # Check and expand enum params, add default values
        completed_params = completeParamValues(params, self.param_registry)  # , lambd_with_params.params)

        # Expand single params and transform them to np.array
        for key in completed_params.keys():
            val = completed_params[key]
            if not isinstance(val, list):
                val = list([val] * param_length)
            completed_params[key] = np.array(val, float)

        # Compute result on whole vectors of parameter samples at a time : lambdas use numpy for vector computation
        def process(args):
            imethod = args[0]
            lambd_with_params: agb.LambdaWithParamNames = args[1]
            value = alpha * lambd_with_params.compute(**completed_params)
            return (imethod, value)

        # Use multithread for that
        with concurrent.futures.ThreadPoolExecutor() as exec:
            for imethod, value in exec.map(process, enumerate(self.lambdas)):
                res[imethod, :] = value

        df = pd.DataFrame(res,
                          index=[agb.method_name(method) + "[%s]" % agb.base_utils._method_unit(method) for method
                                 in self.methods]).transpose()

        # Single params (not a list a param values) ? => give the single row the name of the model activity
        if df.shape[0] == 1:
            model_name = agb.lca._actName(self.model)
            df = df.rename(index={0: model_name})

        return df

    def list_processes(self):
        """
        Lists the processes and their exchanges.
        """
        return self.df_processes

    def list_lcia_functions(self):
        """
        Lists the symbolic expressions of the model for each impact method.
        """
        if self.lambdas is None:
            warn("No symbolic expressions found.")
            return None
        exprs = {method_name: self.lambdas[i] for i, method_name in enumerate(self.methods)}
        df = pd.DataFrame(exprs.values(),
                          index=pd.MultiIndex.from_tuples(exprs.keys()),
                          columns=['Symbolic expressions'])
        return df

    def list_methods(self):
        """
        Lists the methods declared in the LCA problem.
        """
        methods = pd.DataFrame(self.methods)
        return methods


class LCAProblem:
    """
    Base LCA Problem.
    """

    def __init__(self, load_from_file: str = None):
        self.project = DEFAULT_PROJECT  # Project name
        self.model = None  # LCA model
        self.methods = None  # LCIA methods
        self.user_db_path = None  # path to foreground database with parameters

        if load_from_file is not None:
            self._load(load_from_file)

    def _load(self, file_path: str):
        """
        Loads a pre-existing LCA problem.
        """
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        with open(file_path, 'rb') as file:
            data = dill.load(file)
            self.__dict__.update(data)

        # Setup project
        agb.initProject(self.project)

        # Reimport foreground database with parameters
        agb.import_db(USER_DB)

        # Cleaning up the whole foreground database would remove the processes from the imported db...
        agb.resetDb(USER_DB)
        # lcalg.setForeground(USER_DB)

        print(f"Loaded LCA problem from {file_path} and {self.user_db_path}.")

    def save(self, file_path: str):
        """
        Saves the LCA problem for future use.
        """
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        self.user_db_path = os.path.splitext(file_path)[0] + '.bw2'  # Path(file_path).stem + '.bw2'
        agb.export_db(USER_DB, self.user_db_path)  # export foreground database with LCA parameters
        dill.dump(self.__dict__, file=open(file_path, 'wb'))  # Export LCAProblem attributes
        print(f"LCA problem saved in {file_path} and {self.user_db_path}.")

    def compute_lcia(self,
                     split_by=None,
                     functional_unit: ValueOrExpression = 1,
                     return_params: bool = False,
                     description: str = None,
                     **params: Dict[str, Union[float, List[float], np.ndarray]],):
        """
        Similar to main parametric LCIA method from lca_algebraic.
        Only difference is that the model and the LCIA methods are already defined in the problem,
        so the user doesn't have to provide them.
        """

        # LCIA calculation
        res = agb.compute_impacts(
            self.model,  # The model
            self.methods,  # LCIA methods

            # Options
            axis=split_by,  # custom attributes, e.g. 'phase' or 'subphase'. Useful to get contributions to total impact.
            functional_unit=functional_unit,  # impacts will be divided by this value or expr
            return_params=return_params,  # returns the value of all parameters in as tabbed DataFrame
            description=description,  # description to be added in output when using 'return params'

            # Parameters of the model
            **params
        )
        return res

    def generate_reduced_problem(self) -> LCAProblemReduced:
        """
        Generates a reduced LCA problem from the symbolic expressions of the LCIA.
        The reduced problem relies on the symbolic expressions rather than EcoInvent and brightway
        to calculate the impacts.
        """

        with agb.DbContext(USER_DB):
            # Compile symbolic expressions
            lambdas = agb.lca._preMultiLCAAlgebric(self.model, self.methods)

            # Save parameters registry
            param_registry = {param.name: dict(
                group=param.group or "",
                name=param.name,
                label=param.get_label(),
                type=param.type,  # 'enum' if isinstance(param, lcalg.EnumParam) else 'float',
                values=param.values if param.type == 'enum' else None,
                default=param.default,
                min=param.min,
                max=param.max,
                std=getattr(param, "std", None),
                distrib=param.distrib,
                unit=param.unit,
                db=param.dbname or "[project]") for param in agb.params._param_registry().all()}

        # Create reduced problem
        reduced_problem = LCAProblemReduced()
        reduced_problem.model = self.model
        reduced_problem.methods = self.methods
        reduced_problem.lambdas = lambdas
        reduced_problem.param_registry = param_registry
        reduced_problem.df_processes = self.list_processes()

        return reduced_problem

    def list_processes(self, foreground_only: bool = True) -> pd.DataFrame:
        """
        Traverses the tree of sub-activities (sub-processes) until background database is reached.
        """

        activities = []
        units = []
        locations = []
        parents = []
        exchanges = []
        levels = []
        dbs = []

        def _recursive_activities(act,
                                  activities, units, locations, parents, exchanges, levels, dbs,
                                  parent: str = "", exc: dict = None, level: int = 0):

            if exc is None:
                exc = {}
            name = act.as_dict()['name']
            unit = act.as_dict()['unit']
            loc = act.as_dict()['location'] if 'location' in act.as_dict() else ''
            if loc not in ['GLO', '']:
                name += f' [{loc}]'
            exchange = _getAmountOrFormula(exc)
            db = act.as_dict()['database']

            # Stop BEFORE reaching the first level of background activities
            if foreground_only and db != USER_DB:
                return

            activities.append(name)
            units.append(unit)
            locations.append(loc)
            parents.append(parent)
            exchanges.append(exchange)
            levels.append(level)
            dbs.append(db)

            # Stop AFTER reaching the first level of background activities
            if db != USER_DB:
                return

            for exc in act.exchanges():
                if exc.input != act:
                    _recursive_activities(exc.input, activities, units, locations, parents, exchanges, levels, dbs,
                                          parent=name,
                                          exc=exc,
                                          level=level + 1)
            return

        def _getAmountOrFormula(ex):
            """ Return either a fixed float value or an expression for the amount of this exchange"""
            if 'formula' in ex:
                expr = parse_expr(ex['formula'])
                try:
                    float(expr)
                    return format_number(float(expr))
                except TypeError:
                    return expr
            elif 'amount' in ex:
                return format_number(ex['amount'])
            return ""

        _recursive_activities(self.model, activities, units, locations, parents, exchanges, levels, dbs)
        data = {'activity': activities,
                'unit': units,
                'location': locations,
                'level': levels,
                'database': dbs,
                'parent': parents,
                'exchange': exchanges}

        df = pd.DataFrame(data, index=activities)

        return df

    def list_methods(self):
        """
        Lists the methods declared in the LCA problem.
        """
        methods = pd.DataFrame(self.methods)
        return methods


def get_parameter(key: str):
    param = agb.params._param_registry().__getitem__(key)
    return param


def expandParams(param, value=None):
    """
    Modified version of expandParams from classes EnumParam and ParamDef from lca_algebraic library.
    For enum (switch) parameters, returns a dictionary of single enum values as sympy symbols,
    with only a single one set to 1.
    For float parameters, returns a dictionary with either the user-provided value or the default parameter value.
    """

    # Enum (e.g. switch) parameters
    if param['type'] == 'enum':
        values = param['values'] + [None]

        # Bad value ?
        if value not in values:
            raise Exception("Invalid value %s for param %s. Should be in %s" %
                            (value, param['name'], str(param['values'])))

        res = dict()
        for enum_val in values:
            var_name = "%s_%s" % (param['name'], enum_val if enum_val is not None else "default")
            res[var_name] = 1.0 if enum_val == value else 0.0
        return res

    # Float parameters
    else:
        if value is None:
            value = param['default']
        return {param['name']: value}


def completeParamValues(params, param_registry, setDefaults=True):
    """
    Modified version of completeParamValues from lca_algebraic library.
    Sets default values for missing parameters and expand enum params.

    Returns
    -------
        Dict of param_name => float value
    """

    # Set default variables for missing values
    if setDefaults:
        for name, param in param_registry.items():
            if not name in params:
                params[name] = param['default']
                agb.warn(
                    "Required param '%s' was missing, replacing by default value : %s" % (name, str(param['default'])))

    res = dict()
    for key, val in params.items():
        if key in param_registry:
            param = param_registry[key]
        else:
            continue
            # raise Exception("Parameter not found : %s. Valid parameters : %s" % (key, list(param_registry.keys())))

        if isinstance(val, list):
            newvals = [expandParams(param, val) for val in val]
            res.update(agb.params._listOfDictToDictOflist(newvals))
        else:
            res.update(expandParams(param, val))

    return res


def format_number(num, precision=2):
    """
    This function takes a number (either a Python float or a SymPy Float) and a precision,
    and returns a string that represents the number with the given precision.
    If the number is too large or too small, it switches to scientific notation.

    :param num: The number to format.
    :param precision: The number of decimal places to use.
    :return: A string that represents the number with the given precision.
    """
    if isinstance(num, Float):  # SymPy float
        num = num.evalf()
    sci_num = "{:.{}e}".format(num, precision)
    if 'e+00' in sci_num:
        return "{:.{}f}".format(num, precision)
    else:
        return sci_num