from typing import Dict, List, Union
import os
import dill
import lca_algebraic as agb
from lca_algebraic.log import warn
from lca_algebraic import ValueOrExpression
import pandas as pd
from lcav.helpers import list_processes, completeParamValues
import numpy as np
import concurrent.futures

USER_DB = 'Foreground DB'
DEFAULT_PROJECT = 'lcav_default_project'


class LCAProblemReduced:
    """
    DEPRECATED (TO BE UPDATED).
    Reduced LCA Problem.
    This reduced problem does not require EcoInvent and to setup a brightway/lca_algebraic project.
    It is generated by a full LCA problem (see LCAProblem class).
    The LCIA relies on previously compiled expressions of the impacts.
    """

    def __init__(self, load_from_file: str = None):
        self.model = None  # model
        self.methods = None  # LCIA methods
        self.lambdas = None  # Compiled expressions of impacts
        self.param_registry = None  # Parameters
        self.df_processes = None

        if load_from_file is not None:
            self._load(load_from_file)

    def _load(self, file_path: str):
        """
        Loads a pre-existing LCA problem.
        """
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        with open(file_path, 'rb') as file:
            data = dill.load(file)
            self.__dict__.update(data)

        print(f"Loaded LCA problem from {file_path}.")

    def save(self, file_path: str):
        """
        Saves the LCA problem for future use.
        """
        if not self.lambdas:
            warn("No symbolic expression registered in LCA problem.")
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        dill.dump(self.__dict__, file=open(file_path, 'wb'))  # Export LCAProblemReduced attributes
        print(f"LCA problem saved in {file_path}.")

    def compute_lcia(self, alpha=1, **params):
        """
        Modified version of postMultiLCAAlgebric from lca_algebraic library.

        Parameters
        ----------
        **params : dictionary of parameters and their values for calculating the LCIA
        """

        if self.lambdas is None:
            warn("No symbolic expression registered in LCA problem.")
            return None

        param_length = agb.lca._compute_param_length(params)

        # Init output
        res = np.zeros((len(self.methods), param_length), float)

        # Check and expand enum params, add default values
        completed_params = completeParamValues(params, self.param_registry)  # , lambd_with_params.params)

        # Expand single params and transform them to np.array
        for key in completed_params.keys():
            val = completed_params[key]
            if not isinstance(val, list):
                val = list([val] * param_length)
            completed_params[key] = np.array(val, float)

        # Compute result on whole vectors of parameter samples at a time : lambdas use numpy for vector computation
        def process(args):
            imethod = args[0]
            lambd_with_params: agb.LambdaWithParamNames = args[1]
            value = alpha * lambd_with_params.compute(**completed_params)
            return (imethod, value)

        # Use multithread for that
        with concurrent.futures.ThreadPoolExecutor() as exec:
            for imethod, value in exec.map(process, enumerate(self.lambdas)):
                res[imethod, :] = value

        df = pd.DataFrame(res,
                          index=[agb.method_name(method) + "[%s]" % agb.base_utils._method_unit(method) for method
                                 in self.methods]).transpose()

        # Single params (not a list a param values) ? => give the single row the name of the model activity
        if df.shape[0] == 1:
            model_name = agb.lca._actName(self.model)
            df = df.rename(index={0: model_name})

        return df

    def list_processes(self):
        """
        Lists the processes and their exchanges.
        """
        return self.df_processes

    def list_lcia_functions(self):
        """
        Lists the symbolic expressions of the model for each impact method.
        """
        if self.lambdas is None:
            warn("No symbolic expressions found.")
            return None
        exprs = {method_name: self.lambdas[i] for i, method_name in enumerate(self.methods)}
        df = pd.DataFrame(exprs.values(),
                          index=pd.MultiIndex.from_tuples(exprs.keys()),
                          columns=['Symbolic expressions'])
        return df

    def list_methods(self):
        """
        Lists the methods declared in the LCA problem.
        """
        methods = pd.DataFrame(self.methods)
        return methods


class LCAProblem:
    """
    Base LCA Problem.
    """

    def __init__(self, load_from_file: str = None):
        self.project = DEFAULT_PROJECT  # Project name
        self.model = None  # LCA model
        self.methods = None  # LCIA methods
        self.user_db_path = None  # path to foreground database with parameters

        if load_from_file is not None:
            self._load(load_from_file)

    def _load(self, file_path: str):
        """
        Loads a pre-existing LCA problem.
        """
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        with open(file_path, 'rb') as file:
            data = dill.load(file)
            self.__dict__.update(data)

        # Setup project
        agb.initProject(self.project)

        # Reimport foreground database with parameters
        agb.import_db(USER_DB)

        # Cleaning up the whole foreground database would remove the processes from the imported db...
        agb.resetDb(USER_DB)
        # lcalg.setForeground(USER_DB)

        print(f"Loaded LCA problem from {file_path} and {self.user_db_path}.")

    def save(self, file_path: str):
        """
        Saves the LCA problem for future use.
        """
        if not file_path.endswith('.pickle'):
            file_path = file_path + '.pickle'
        self.user_db_path = os.path.splitext(file_path)[0] + '.bw2'  # Path(file_path).stem + '.bw2'
        agb.export_db(USER_DB, self.user_db_path)  # export foreground database with LCA parameters
        dill.dump(self.__dict__, file=open(file_path, 'wb'))  # Export LCAProblem attributes
        print(f"LCA problem saved in {file_path} and {self.user_db_path}.")

    def compute_lcia(self,
                     split_by=None,
                     functional_unit: ValueOrExpression = 1,
                     return_params: bool = False,
                     description: str = None,
                     **params: Dict[str, Union[float, List[float], np.ndarray]],):
        """
        Similar to main parametric LCIA method from lca_algebraic.
        Only difference is that the model and the LCIA methods are already defined in the problem,
        so the user doesn't have to provide them.
        """

        # LCIA calculation
        res = agb.compute_impacts(
            self.model,  # The model
            self.methods,  # LCIA methods

            # Options
            axis=split_by,  # custom attributes, e.g. 'phase' or 'subphase'. Useful to get contributions to total impact.
            functional_unit=functional_unit,  # impacts will be divided by this value or expr
            return_params=return_params,  # returns the value of all parameters in as tabbed DataFrame
            description=description,  # description to be added in output when using 'return params'

            # Parameters of the model
            **params
        )
        return res

    def generate_reduced_problem(self) -> LCAProblemReduced:
        """
        Generates a reduced LCA problem from the symbolic expressions of the LCIA.
        The reduced problem relies on the symbolic expressions rather than EcoInvent and brightway
        to calculate the impacts.
        """

        with agb.DbContext(USER_DB):
            # Compile symbolic expressions
            lambdas = agb.lca._preMultiLCAAlgebric(self.model, self.methods)

            # Save parameters registry
            param_registry = {param.name: dict(
                group=param.group or "",
                name=param.name,
                label=param.get_label(),
                type=param.type,  # 'enum' if isinstance(param, lcalg.EnumParam) else 'float',
                values=param.values if param.type == 'enum' else None,
                default=param.default,
                min=param.min,
                max=param.max,
                std=getattr(param, "std", None),
                distrib=param.distrib,
                unit=param.unit,
                db=param.dbname or "[project]") for param in agb.params._param_registry().all()}

        # Create reduced problem
        reduced_problem = LCAProblemReduced()
        reduced_problem.model = self.model
        reduced_problem.methods = self.methods
        reduced_problem.lambdas = lambdas
        reduced_problem.param_registry = param_registry
        reduced_problem.df_processes = list_processes(self.model)

        return reduced_problem

    def list_methods(self):
        """
        Lists the methods declared in the LCA problem.
        """
        methods = pd.DataFrame(self.methods)
        return methods
